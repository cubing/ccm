/*
 *  jChester - v0.7.2
 *  A time entry component for speedcubing solves.
 *  https://github.com/jfly/jChester
 *
 *  Made by Jeremy Fleischman
 *  Under GPL-3.0 License
 */
(function($) {
  if(!$) {
    // If jQuery is not defined, don't do anything. This library
    // is still useful without jQuery for the utility methods it provides
    // for dealing with SolveTimes.
    return;
  }

  var INPUT_WIDTH_PIXELS = 90;
  var INTEGER_INPUT_WIDTH_PIXELS = 45; // Enough for 3 digits, which is *plenty*
  var MAX_TIME_CHARACTERS = "1:00:00.00".length;

  $.fn.jChester = function(method, _settings) {
    if(!this.is('div')) {
      throw "jChester can only be applied to divs";
    }
    if($.isPlainObject(method)) {
      _settings = method;
      method = null;
    }

    var editableSolveTimeFieldOptions = [ 'millis', 'moveCount', 'puzzlesSolvedCount', 'puzzlesAttemptedCount' ];

    var that = this;
    var settings = $.extend({}, $.fn.jChester.defaults, _settings);

    var data = this.data('jChesterData');
    if(!data) {
      data = {};
      this.data('jChesterData', data);

      data.$form = $('<form class="form-inline" role="form">');
      that.append(data.$form);

      // Create millis field
      data.$form.append($('<div class="form-group"><input type="text" name="millis-mask" class="form-control" readonly tabindex="-1"></input><input name="millis" type="text" class="form-control"></input></div>'));
      data.$form.find('input[name="millis-mask"]').css({
        position: 'absolute',
        backgroundColor: 'white',
        fontFamily: 'monospace',
        textAlign: 'right',
      });
      data.$form.find('input[name="millis"]').css({
        position: 'relative',
        backgroundColor: 'transparent',
        fontFamily: 'monospace',
        textAlign: 'right',
      });
      data.$form.find('input[name="millis"]').attr("maxlength", MAX_TIME_CHARACTERS);

      // Create moveCount field
      data.$form.append($('<div class="form-group"><input name="moveCount" type="text" class="form-control"></input></div>'));

      data.$form.append(document.createTextNode(' '));

      // Create puzzlesSolvedCount field
      data.$form.append($('<div class="form-group"><input name="puzzlesSolvedCount" min="0" type="number" class="form-control"></input></div>'));

      // Create puzzlesAttemptedCount field
      data.$form.append($('<span name="puzzlesAttemptedCount">&nbsp;/&nbsp;</span>'));
      data.$form.append($('<div class="form-group"><input name="puzzlesAttemptedCount" min="0" type="number" class="form-control"></input></div>'));

      data.$form.append($('<span class="help-block">'));

      data.$form.find('input[type="text"]').width(INPUT_WIDTH_PIXELS);
      data.$form.find('input[type="number"]').width(INTEGER_INPUT_WIDTH_PIXELS);

      // Force form to be on one line. Bootstrap's .form-inline only applies
      // when the viewport is at least 768px wide.
      data.$form.find('.form-group').css({ display: 'inline-block' });

      data.inputChanged = function() {
        var errorByField = {};
        var solveTime = null;

        if(data.editableSolveTimeFields.millis) {
          var $inputMillis = data.$form.find('input[name="millis"]');
          var $inputMillisMask = data.$form.find('input[name="millis-mask"]');
          var millisStr = $inputMillis.val();
          // Remove any spaces generated by "lazy" inputting
          millisStr = millisStr.replace(/ /g, "");
          // If the user inputed only digits, treat this as a "lazy" input.
          if(millisStr.match(/^\d+$/)) {
            // Only allow up to 1 digit for hours, 2 digits for minutes,
            // 2 digits for seconds, and 2 digits for decimal places.
            // The WCA doesn't allow times over an hour, and supporting
            // more digits would overflow the space allocated for our inputs,
            // which would require keeping $inputMillis and $inputMillisMask
            // horizontally scroll-locked, which seems really hard/annoying.
            var maxLength = 1 + 2 + 2 + 2;
            if(millisStr.length > maxLength) {
              millisStr = millisStr.substring(0, maxLength);
            }
            var len = millisStr.length;
            var decimalsStr = millisStr.substring(len - 2, len);
            var secondsStr = millisStr.substring(len - 4, len - 2);
            var minutesStr = millisStr.substring(len - 6, len - 4);
            var hoursStr = millisStr.substring(0, len - 6);

            var newClockFormat = "";
            var mask = "";
            var append = function(str, padding) {
              for(var i = 0; i < padding - str.length; i++) {
                newClockFormat += " ";
                mask += "0";
              }
              newClockFormat += str;
              mask += str;
            };
            if(hoursStr.length > 0) {
              append(hoursStr, 1);
              append(":", 0);
            }
            if(minutesStr.length > 0) {
              append(minutesStr, mask.length > 0 ? 2 : 1);
              append(":", 0);
            }
            append(secondsStr, mask.length > 0 ? 2 : 1);
            append(".", 0);
            append(decimalsStr, 2);
            // Make space for the colon and period. Note that we don't
            // actually make them part of the input, we just leave space
            // for them to be shown in the $inputMillisMask.
            $inputMillis.val(newClockFormat.replace(/[.:]/g, " "));
            $inputMillisMask.val(mask);

            millisStr = newClockFormat.replace(/ /g, "0");
          } else {
            // Only bother setting the value if it's really neccessary.
            // This way we don't screw up a user who has moved back to edit
            // something earlier in the input field.
            if(millisStr !== $inputMillis.val()) {
              $inputMillis.val(millisStr);
            }
            $inputMillisMask.val('');
          }
          try {
            solveTime = jChester.stopwatchFormatToSolveTime(millisStr);
          } catch(e) {
            if(millisStr.length === 0) {
              errorByField.millis = "Please enter a time.";
            } else {
              errorByField.millis = e;
            }
          }
        }

        if(data.editableSolveTimeFields.moveCount) {
          var moveCountStr = data.$form.find('input[name="moveCount"]').val();
          try {
            if(solveTime) {
              $.extend(solveTime, jChester.stopwatchFormatToSolveTime(moveCountStr, true));
            } else {
              solveTime = jChester.stopwatchFormatToSolveTime(moveCountStr, true);
            }
          } catch(e) {
            if(moveCountStr.length === 0) {
              errorByField.moveCount = "Please enter a number of moves.";
            } else {
              errorByField.moveCount = e;
            }
          }
        }

        var puzzlesSolvedCountStr;
        var puzzlesAttemptedCountStr;
        data.hideField = {};
        if(!solveTime) {
          puzzlesSolvedCountStr = null;
          puzzlesAttemptedCountStr = null;
          data.hideField.puzzlesSolvedCount = true;
          data.hideField.puzzlesAttemptedCount = true;
        } else if(jChester.solveTimeIsDNF(solveTime)) {
          puzzlesSolvedCountStr = "0";
          puzzlesAttemptedCountStr = "1";
          data.hideField.puzzlesSolvedCount = true;
          data.hideField.puzzlesAttemptedCount = true;
        } else if(jChester.solveTimeIsDNS(solveTime)) {
          puzzlesSolvedCountStr = "0";
          puzzlesAttemptedCountStr = "0";
          data.hideField.puzzlesSolvedCount = true;
          data.hideField.puzzlesAttemptedCount = true;
        } else if(data.editableSolveTimeFields.puzzlesSolvedCount || data.editableSolveTimeFields.puzzlesAttemptedCount) {
          var $inputPuzzlesSolvedCount = data.$form.find('input[name="puzzlesSolvedCount"]');
          puzzlesSolvedCountStr = $inputPuzzlesSolvedCount.val();
          var $inputPuzzlesAttemptedCount = data.$form.find('input[name="puzzlesAttemptedCount"]');
          puzzlesAttemptedCountStr = $inputPuzzlesAttemptedCount.val();
        } else {
          puzzlesSolvedCountStr = "1";
          puzzlesAttemptedCountStr = "1";
        }

        if(solveTime) {
          if(jChester._isInt(puzzlesSolvedCountStr)) {
            var puzzlesSolvedCount = parseInt(puzzlesSolvedCountStr);
            solveTime.puzzlesSolvedCount = puzzlesSolvedCount;
          } else {
            errorByField.puzzlesSolvedCount = 'Invalid number of puzzles solved.';
          }

          if(jChester._isInt(puzzlesAttemptedCountStr)) {
            var puzzlesAttemptedCount = parseInt(puzzlesAttemptedCountStr);
            solveTime.puzzlesAttemptedCount = puzzlesAttemptedCount;
            if(!errorByField.puzzlesSolvedCount && solveTime.puzzlesSolvedCount > solveTime.puzzlesAttemptedCount) {
              errorByField.puzzlesAttemptedCount = 'Cannot have more puzzles solved than attemped.';
            }
          } else {
            errorByField.puzzlesAttemptedCount = 'Invalid number of puzzles attempted.';
          }
        }

        var getErrorForField = function(field) {
          return errorByField[field];
        };
        data.validationErrors = editableSolveTimeFieldOptions.filter(getErrorForField).map(getErrorForField);
        if(data.validationErrors.length > 0) {
          solveTime = null;
        }
        data.solveTime = solveTime;

        // TODO - it would be nice if the errors lined up with the appropriate
        // inputs somehow. Perhaps we could have tooltips/popovers on each field?
        data.$form.find('.help-block').text(data.validationErrors.join(" "));
        data.$form.find('.input-group').removeClass('has-error');
        editableSolveTimeFieldOptions.forEach(function(field) {
          var $inputForField = data.$form.find('input[name="' + field + '"]');
          var $formGroupForField = $inputForField.parent('.form-group');
          var hasError = !!errorByField[field];
          $formGroupForField.toggleClass('has-error', hasError);
        });

        editableSolveTimeFieldOptions.forEach(function(field) {
          var fieldVisible = data.editableSolveTimeFields[field] && !data.hideField[field];
          fieldVisible = !!fieldVisible; // $.toggle requires a real boolean
          data.$form.find('input[name="' + field + '"]').parent().toggle(fieldVisible);
          data.$form.find('span[name="' + field + '"]').toggle(fieldVisible);
        });
      };

      data.$form.find("input").on("input", function() {
        data.inputChanged();
        that.trigger("solveTimeInput", [data.validationErrors, data.solveTime]);
      });

      data.$form.find("input").on('keydown', function(e) {
        var $target = $(e.currentTarget);
        if(($target.attr('name') === 'millis' || $target.attr('name') === 'moveCount') && !e.altKey && !e.ctrlKey & !e.metaKey) {
          if(e.which === 106 || e.which === 68) { // asterisk or "d" key
            $target.val("DNF");
            $target.select(); // select all to make it easier to change
            data.inputChanged();
            that.trigger("solveTimeInput", [[], data.solveTime]);
            e.preventDefault();
          } else if(e.which === 111 || e.which === 83) { // forward slash or "s" key
            $target.val("DNS");
            $target.select(); // select all to make it easier to change
            data.inputChanged();
            that.trigger("solveTimeInput", [[], data.solveTime]);
            e.preventDefault();
          }
        }
      });

      this.attr("tabindex", "-1");
      this.focus(function(e) {
        var $input = $(this).find('input:visible:not([readonly])').first();
        $input.focus();
        $input.select();
      });
    }

    var setSolveTime = function(solveTime) {
      if(solveTime === null) {
        // If solveTime is explicitly set to null, clear
        // the current input and validation state.
        data.$form.find('input[name="millis"]').val('');
        data.$form.find('input[name="moveCount"]').val('');
        data.$form.find('input[name="puzzlesSolvedCount"]').val('');
        data.$form.find('input[name="puzzlesAttemptedCount"]').val('');
        data.inputChanged();
      } else if(solveTime) {
        var dnStr = "";
        if(jChester.solveTimeIsDNF(solveTime)) {
          dnStr = "DNF";
        } else if(jChester.solveTimeIsDNS(solveTime)) {
          dnStr = "DNS";
        }

        var millisStr;
        if(solveTime.millis) {
          millisStr = jChester.solveTimeToStopwatchFormat(solveTime, true);
        } else {
          millisStr = dnStr;
        }
        data.$form.find('input[name="millis"]').val(millisStr);

        var moveCountStr;
        if(solveTime.moveCount) {
          moveCountStr = solveTime.moveCount;
        } else {
          moveCountStr = dnStr;
        }
        data.$form.find('input[name="moveCount"]').val(moveCountStr);

        data.$form.find('input[name="puzzlesSolvedCount"]').val(solveTime.puzzlesSolvedCount);
        data.$form.find('input[name="puzzlesAttemptedCount"]').val(solveTime.puzzlesAttemptedCount);
        data.inputChanged();
      }
    };

    if(method === 'getSolveTime') {
      return data.solveTime;
    } else if(method === 'setSolveTime') {
      var solveTime = arguments[1];
      setSolveTime(solveTime);
      return;
    } else if(method === 'getValidationErrors') {
      return data.validationErrors;
    } else if(method) {
      throw "Unrecognized method: " + method;
    }

    data.editableSolveTimeFields = settings.editableSolveTimeFields;
    data.inputChanged();

    setSolveTime(settings.solveTime);
    return that;
  };

  $.fn.jChester.defaults = {
    solveTime: null,
    editableSolveTimeFields: {
      millis: true,
    }
  };

}(typeof jQuery === "undefined" ? null : jQuery));

var MILLIS_PER_SECOND = 1000;
var MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;

jChester = {
  stopwatchFormatToSolveTime: function(stopwatchFormat, isMoveCount) {
    if(stopwatchFormat.length === 0) {
      return null;
    }
    if(stopwatchFormat.toUpperCase() === 'DNF') {
      return {
        puzzlesSolvedCount: 0,
        puzzlesAttemptedCount: 1,
      };
    }
    if(stopwatchFormat.toUpperCase() === 'DNS') {
      return {
        puzzlesSolvedCount: 0,
        puzzlesAttemptedCount: 0,
      };
    }

    if(isMoveCount) {
      if(!jChester._isInt(stopwatchFormat)) {
        throw "Invalid move count.";
      }
      var moveCount = parseInt(stopwatchFormat);
      if(moveCount <= 0) {
        throw "Move count must be greater than zero.";
      }
      return {
        moveCount: moveCount,
      };
    }

    var m = stopwatchFormat.match(/^(?:(\d*):)??(?:(\d*):)?(\d+)?(?:[.,](\d*))?$/);
    if(!m) {
      throw "Invalid stopwatch format.";
    }

    var hours = parseInt(m[1] || "0");
    var minutes = parseInt(m[2] || "0");
    var seconds = parseInt(m[3] || "0");
    var decimalStr = m[4] || "";
    var decimal = parseInt(decimalStr || "0");
    var denominator = Math.pow(10, decimalStr.length - 3); /* subtract 3 to get millis instead of seconds */
    var decimalValueInMillis = !decimal ? 0 : Math.round(decimal / denominator);

    var millis = hours * MILLIS_PER_HOUR + minutes * MILLIS_PER_MINUTE + seconds * MILLIS_PER_SECOND + decimalValueInMillis;
    if(millis <= 0) {
      throw "Time must be greater than zero.";
    }
    var decimals = Math.min(3, decimalStr.length); /* max allowed decimals is 3 */
    return {
      millis: millis,
      decimals: decimals,
    };
  },
  solveTimeIsDNF: function(solveTime) {
    if(typeof solveTime.puzzlesSolvedCount !== 'undefined' && typeof solveTime.puzzlesAttemptedCount !== 'undefined') {
      if(solveTime.puzzlesAttemptedCount === 1) {
        // This is *not* a multi attempt.
        if(solveTime.puzzlesSolvedCount === 0) {
          return true;
        }
      } else if(solveTime.puzzlesAttemptedCount > 1) {
        // By https://www.worldcubeassociation.org/regulations/#H1a,
        // multibld results must have at least 2 puzzles attempted.
        /* From https://www.worldcubeassociation.org/regulations/#9f12c
        9f12c) For Multiple Blindfolded Solving, rankings are
        assessed based on number of puzzles solved minus the number
        of puzzles not solved, where a greater difference is better.
        If the difference is less than 0, or if only 1 puzzle is
        solved, the attempt is considered unsolved (DNF). If
        competitors achieve the same result, rankings are assessed
        based on total time, where the shorter recorded time is
        better. If competitors achieve the same result and the same
        time, rankings are assessed based on the number of puzzles
        the competitors failed to solve, where fewer unsolved
        puzzles is better.
        */
        var puzzleUnsolved = solveTime.puzzlesAttemptedCount - solveTime.puzzlesSolvedCount;
        var solvedMinusUnsolved = solveTime.puzzlesSolvedCount - puzzleUnsolved;
        if(solvedMinusUnsolved < 0 || solveTime.puzzlesSolvedCount === 1) {
          return true;
        }
      }
    }
    return false;
  },
  solveTimeIsDNS: function(solveTime) {
    if(typeof solveTime.puzzlesAttemptedCount !== 'undefined') {
      if(solveTime.puzzlesAttemptedCount === 0) {
        return true;
      }
    }
    return false;
  },
  solveTimeIsDN: function(solveTime) {
    return jChester.solveTimeIsDNF(solveTime) || jChester.solveTimeIsDNS(solveTime);
  },
  solveTimeToStopwatchFormat: function(solveTime, ignoreDn) {
    if(!solveTime) {
      return "";
    }
    if(!ignoreDn) {
      if(jChester.solveTimeIsDNF(solveTime)) {
        return "DNF";
      } else if(jChester.solveTimeIsDNS(solveTime)) {
        return "DNS";
      }
    }

    if(solveTime.moveCount) {
      // jChester's solveTimeToStopwatchFormat doesn't handle FMC, which is fine,
      // FMC is *weird*.
      return solveTime.moveCount.toFixed(solveTime.decimals || 0);
    }

    var millis = solveTime.millis;

    var hoursField = Math.floor(millis / MILLIS_PER_HOUR);
    millis %= MILLIS_PER_HOUR;

    var minutesField = Math.floor(millis / MILLIS_PER_MINUTE);
    millis %= MILLIS_PER_MINUTE;

    var secondsField = Math.floor(millis / MILLIS_PER_SECOND);
    millis %= MILLIS_PER_SECOND;

    function pad(toPad, padVal, minLength) {
      var padded = toPad + "";
      while(padded.length < minLength) {
        padded = padVal + padded;
      }
      return padded;
    }

    var stopwatchFormat = "";
    if(stopwatchFormat.length > 0) {
      stopwatchFormat += ":" + pad(hoursField, "0", 2);
    } else if(hoursField) {
      stopwatchFormat += hoursField;
    }
    if(stopwatchFormat.length > 0) {
      stopwatchFormat += ":" + pad(minutesField, "0", 2);
    } else if(minutesField) {
      stopwatchFormat += minutesField;
    }
    if(stopwatchFormat.length > 0) {
      stopwatchFormat += ":" + pad(secondsField, "0", 2);
    } else {
      stopwatchFormat += secondsField;
    }
    var decimals = solveTime.decimals;
    if(decimals > 0) {
      // It doesn't make sense to format to more decimal places than the
      // accuracy we have.
      decimals = Math.min(3, decimals);
      var millisStr = pad(millis, "0", 3);
      stopwatchFormat += ".";
      for(var i = 0; i < decimals; i++) {
        stopwatchFormat += millisStr.charAt(i);
      }
    }
    return stopwatchFormat;
  },
  _isInt: function(n) {
    if(n.length === 0) {
      return false;
    }
    return (+n % 1) === 0;
  },
};
